TODO:
- sampling based polynomial trajectory generation

start config: current car config (localization and sensors) carSTate
goal configuration: from behavior where to go at which speed
incorporate predictions to take other cars into account, and our actions
 effecting other cars.

constraints - dynamics

feasible motion dynamics

minimze cost function

sampling based methods
Collision Detection module

Frenet reminder
road structure as reference path

don't just compute sequence of configuration but also WHEN (the need for time)

need s, d, AND t.
same with x/y

Seperate planning we do in the s dimension, from the planning we do in the d dimension.

reason about 2 2d pictures, one for s and one for d.

boundary conditions
jerk minization
polynomial tratjectories (spline ?)

trajectory generation algorithm (select best trajectory)

change lanes 10 seconds later (goal conditon, start condition)
these are the boundary conditions

Motion Control Module
position continuity
velocity continuity (speed)
accelartion continuty and jerk contunity

accelertion

jerk quantity as uncomfortable this needs to be mimized.
easy to do jerk min in 1D.

total squared jerk mimize this. 6 or more time steps need to mimizied jerk
see: Jerk Minimizing Trajectories
6 coefficents -> 6 tunable parameters -> 6 boundary conditions

s(t)

s_t0 -> s_tfinal

jerk 3rd derivative of position

total squared jerk

generate trajectory

initial s0 = 0

Sim start:
s = 124

6 boundary conditions (constraints)
longitudinal displacement
[inital_position, initial_velocity, initial_acceleration, final_position, final_velocity, final_acceleration]

same for lateral displacement
[inital_position, initial_velocity, initial_acceleration, final_position, final_velocity, final_acceleration]

Lane Change


d inital and final velocities and acceleration are 0
[0, 0, 0, 10, 0, 0]

x axis is time and y axis is d

quintic polynomial how to find the coeffecients

choose t=0



Implement Polynomial Solver (s)
inputs: [s0_pos, s0_vel, s0_acc], [sf_pos, sf_vel, sf_acc], T
outputs: 6 coefficients that uniquely describe the longitudinal (s) trajectory

(d)
inputs: [d0_pod, d0_vel, d0_acc], [df_pod, df_vel, df_acc], T
outputs: 6 coefficients that uniquely describe the lateral (s) trajectory




feasibility loop through trajectory and check tests


Hi, the s_double_dot ist the accelaration in frenet s coordinate
so the difference between two points s1 and s2 is the s_dot which is the velocity in frenet s coordinate
the result (s1 -s2) - (s2 -s3) is the s_double_dot
so you need the last two points to calculate the current s_double_do


===================
Let me share my "pain" , that may help other from doing the same mistake.

*My mistake:* I was *measuring* acceleration (timing from update to update) and doing du/dt. But that was a *grave* error.
What I was calculating was the average acceleration. So my acceleration at the end was bigger and incompatible with my new segment.

Changed that , to a simple "3 points rule" from the previous curve, and everything is fine! (except my head which is exploding from my silly mistake) :slightly_smiling_face:

Ofcourse you can play it "safe" and chain paths, have zero acceleration at the end points and let the jmt do the job for you, BUT that means if there is an incident and you have to change your path earlier, you are screwed


=====================
To avoid discontinuities, I had to calculate the start distance, speed, and acceleration using current JMT before re-calculating the new JMT for the next update. The end values (excluding considerations for any collision avoidance) will be the start position (s) + an estimate of the distance covered during the update, the max velocity, and 0 acceleration. You can then permute over a sub-range of final s and velocity values and exclude JMTs that violate the speed limit, acceleration limits, and jerk limits. (edited)

======

Ah, and the velocity and acceleration that the sim is judging by are what Kostas writes below - v is based on previous points, and a is based on the previous 3 points

======

I did not use the speed or s from the simulator. I found those to be deceiving in terms of using them as the true instantaneous velocity and distance - they seemed to not line up with the my predicted values based on the number of points the simulator had consumed; they appear to be approximations or averages over time, not an instantaneous value. Remember that the simulator 'teleports' the car given the points you provided so you should have perfect knowledge of where the car is and what its instantaneous speed is at all times with the JMT equations. I'm using the remaining points from the previous update instead to determine exactly where the car is and its velocity based on my previous JMT


======

Jose Rojas [22 hours ago] 
I'm using a JMT to generate a function s(t) -> so the domain would be time to generate the 's' distance along the road. I then map the 's' points generated by this function with uniform time step to x and y using a spline interpolation. I may need to re-evaluate some of this because I do see some cases where the speed limits are surpassed - I believe this might be caused by not considering the 2d forces (tangential, normal) in the x,y coordinate space by only considering the motion as 1 dimensional along d. But this should get you most of the way there - I see these edge cases at specific places along the road (about 3-4 times through the track).

=====

Yes, this works. You can calculate distance, speed, acceleration using your previous JMT to calculate the starting parameters for the next JMT update.

====

Kostas Oreopoulos [1:29 PM] 
In case some else was struggling, The naive solution is always the best. To deal with the car speeding because s is linear and the car is in curves, the following seems to work pretty well.
* once you have your splines and you can convert from s,d to xy in continuous fashion, then do the following
* take for example from the point you are a distance of 100 meters (the next) and divide it in 4-5-6 points you want.
Then for those all those points calculate the XY coodinates and add the distances  (1-2, 2-3.. etc) . You will get a distance Dxy.
If its a straight line you are driving, then Ds (which is just the difference of the first and last points) should be equal to Dxy.
Dxy > Ds, means you are turning, thus travelling a bigger distance. So the speed you said you liked... Dv, which was Ds/dt will in fact to Dxy/dt.
So to compensate you should tell the vehicle to scale down the velocity by that factor (Ds / Dxy) OR , you can apply that directy to the distance you tell it to travel (more accurate )


sensor_fusion:
 [ id, x, y, vx, vy, s, d]

[[0,915.2576,1132.84,21.04151,0.1510535,130.647,2.04525],[1,1108.025,1181.13,15.9365,2.422745,331.3928,5.457354],[2,885.5003,1128.804,13.37166,-0.0386542,100.9089,6.000782],[3,868.8564,1132.843,23.44067,-0.09241272,84.26991,1.985798],[4,1098.41,1175.352,15.75051,3.590922,320.0074,9.316438],[5,897.6356,1128.785,21.88129,0.004136397,113.0441,6.016078],[6,762.1,1421.6,0,0,6711.778,-268.0964],[7,762.1,1425.2,0,0,6709.296,-270.7039],[8,762.1,1429,0,0,6663.543,-273.1828],[9,762.1,1432.9,0,0,6660.444,-275.5511],[10,762.1,1436.3,0,0,6657.743,-277.6157],[11,762.1,1441.7,0,0,6653.453,-280.8947]]


TODO: for jerk
https://discussions.udacity.com/t/latency-handling/322156/6


[
 [0,923.9572,1124.931,20.58825,0.2107511,139.278,10.02884],
 [1,1150.794,1180.974,17.98089,1.213317,374.347,9.90862],
 [2,1080.441,1178.414,17.27473,6.725935,303.3093,2.00729]
 ,[3,1108.639,1185.321,17.53257,2.339978,332.5406,1.379813],

[4,884.8474,1132.787,21.82869,-0.1260071,100.2547,2.018312],[5,1086.119,1176.089,16.60239,5.430759,308.2582,5.634878],[6,913.4125,1128.832,21.3738,0.1376782,128.7674,6.036598],[7,762.1,1425.2,0,0,6709.296,-270.7039],[8,762.1,1429,0,0,6663.543,-273.1828],[9,762.1,1432.9,0,0,6660.444,-275.5511],[10,762.1,1436.3,0,0,6657.743,-277.6157],[11,762.1,1441.7,0,0,6653.453,-280.8947]]

car: 0, 0, 0, 0, 0, 0, 0, 
car: 1152.59, 1152.59, 1152.59, 1152.59, 1152.59, 1152.59, 1152.59, 
car: 1179.07, 1179.07, 1179.07, 1179.07, 1179.07, 1179.07, 1179.07, 
car: 17.5234, 17.5234, 17.5234, 17.5234, 17.5234, 17.5234, 17.5234, 
car: -0.106077, -0.106077, -0.106077, -0.106077, -0.106077, -0.106077, -0.106077, 
car: 309.998, 309.998, 309.998, 309.998, 309.998, 309.998, 309.998, 
car: 6.04045, 6.04045, 6.04045, 6.04045, 6.04045, 6.04045, 6.04045, 
car: 2.71557e-33, 2.71557e-33, 2.71557e-33, 2.71557e-33, 2.71557e-33, 2.71557e-33, 2.71557e-33, 
car: 1.49167e-154, 1.49167e-154, 1.49167e-154, 1.49167e-154, 1.49167e-154, 1.49167e-154, 1.49167e-154, 
car: 1.49167e-154, 1.49167e-154, 1.49167e-154, 1.49167e-154, 1.49167e-154, 1.49167e-154, 1.49167e-154, 
car: 5.64235e-38, 5.64235e-38, 5.64235e-38, 5.64235e-38, 5.64235e-38, 5.64235e-38, 5.64235e-38, 
car: 1.82919e-76, 1.82919e-76, 1.82919e-76, 1.82919e-76, 1.82919e-76, 1.82919e-76, 1.82919e-76,

I have compiled a short summary of things I struggled with so far and I would've benefited of knowing when starting the project. I hope someone who starts the project just now will find it useful:

- read carefully both the `README.md` and the project description - they don't have the same information
 - `previous_path_x` and `previous_path_y` are always the future `n` steps of your car, i.e. they don't include `x` and `y`
- your car's `x` and `y` are always one of the points you've sent to the simulator in the previous cycle
 - some of the other cars don't appear immediately on the road and will have strange coordinates, e.g. `d = -200`
- the provided coordinate conversion functions are not smooth at all and you need to make your own
 - you can use `spline` for `Frenet` -> `Cartesian` XY conversion, where you fit `x` and `y` to `s`
- your conversion will never be completely accurate (expect displacements of 0 to 0.5 per axis, 0.1 on average)
 - always be careful when handling `s` - remember that the track is a circuit and `s` values around `0` and `6945.554` are fiddly to work with  
- `Cartesian` XY -> `Frenet` is very inaccurate and complicated to improve, also not very useful
 - the time between two cycles is ~2-3 steps, i.e. `0.04s-0.06s`
- it is very useful to always include >3 previous path values to your next values for avoiding crazy behaviour of your car
 - generate your trajectory from your car's position in a couple of steps from now (maybe 10?)
 - when getting your car coordinates, don't rely on the provided `s`, `d` or `speed`
- keep your previous trajectory in `Frenet` and `Cartesian` and use it for calculating `s`, `d`, `s_dot` and `d_dot` from your car's `x` and `y` from the simulator
 - all cars are roughly ~5m long - use that knowledge for calculating buffer distance (edited)


1.  yaw = atan2(vy, vx)
2.  calculate lane orientation (from closesestWaypoint and next of the car OR by using the spline representation of the track you can just
find for car_s  X,Y (s) and X,Y (s+delta_s) and find the atan2(DY,DX). Let call that lane orientation

3.  yaw - lane.orientation = *local yaw* (how the car is with reference to the lane)
4. v = sqrt(vx * vx + vy * vy)
5 v_s = v * cos(local_yaw)
6  v_d = v * cos(local_yaw)

and you are done

vector<double> Vehicle::getStateAt(double time) {
  double new_s = s + v_s * time;
  double new_d = d + v_d * time;
  return vector<double>{new_s, new_d, v_s, v_d};
}


-MAX_A < J*DT < MAX_A
then after getting this bounds , I did the same with velocity

V_Target = V0 + A0*DT + 0.5*J*DT^2. . Solved for J and applied bounds.
Then S = S0 + V0DT + 0.5*A0DT^2 + 1/6 JDT^3

The first one is simple bounds.. In case your duration is more than 1 sec..
Its says  J < ABS(10*DT)


[5:27] 
that is easy... Then you want to reach velocity V_target... 20, 30... .. MAX....
You know your V0 (the one at start of the goal)... you know your acceleration... so solve for J


[5:27] 
Is J within limits? if no... get the max J allowed (or min if its negative)

so now you know a legal J... and you calculate how far you go.... Applyting to S
